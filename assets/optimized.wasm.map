{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/utils.ts","assembly/index.ts","assembly/drawCross.ts","assembly/variance-average-brightness.ts"],"names":[],"mappings":"6FEUQ,AAAU,EAAY,KACtB,EAA0B,KAC1B,EAA0B,KAC1B,EAA0B,YEJ1B,AAAiC,AAHR,EAAa,KAGS,AADnB,EAAa,QAEzC,AAA8B,AAAc,EAAd,KAC9B,AAAkC,AAJR,EAAc,KAIS,KACjD,AAA+B,AAAe,EAAf,OAEb,AAAM,EAAN,KACT,AAAU,MAAG,AAAM,EAAN,KAEd,AAAmB,EAAW,AADZ,AAAC,AAAsB,EAArB,AAAM,EAAN,IAA6B,QAE7C,EAAyD,AAA6B,EAAM,KAAnC,EAAM,IAA/D,AAA8B,EAAM,KAApC,EAAM,OACI,EAAY,GAAK,EAAG,MFD1C,AAAU,EAAY,AEGA,QFFtB,AAAU,EAAgB,AAAS,QACnC,AAAU,EAAgB,AAAS,QACnC,AAAU,EAAgB,AAAS,SENK,WADH,WAWrC,KDpBJ,AAAuB,EAAU,EAAY,EAAa,WEKtC,AAAI,EAAJ,KAIF,AAHS,EAAW,GAGR,AADV,AAAI,AAAU,AAAS,MAAnB,UAAwB,AAAU,AAAS,MAAnB,WAA4B,AAAU,AAAS,MAAnB,cACzC,EAAK,IAJN,EAAK,SFDvC","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","export class Color {\n    constructor(public r: i32, public  g: i32, public b: i32, public  a: i32) {\n    }\n}\n\nexport namespace Util {\n\n    export const COLOR_WIDTH = 4;\n\n    export function fill(writeIndex: i32, r: i32, g: i32, b: i32, a: i32): i32 {\n        store<u8>(writeIndex, r);\n        store<u8>(writeIndex + 1, g);\n        store<u8>(writeIndex + 2, b);\n        store<u8>(writeIndex + 3, a);\n        return 0;\n    }\n\n    export function copy(readIndex: i32, writeIndex: i32): i32 {\n        store<u8>(writeIndex, load<u8>(readIndex));\n        store<u8>(writeIndex + 1, load<u8>(readIndex + 1));\n        store<u8>(writeIndex + 2, load<u8>(readIndex + 2));\n        store<u8>(writeIndex + 3, load<u8>(readIndex + 3));\n        return 0;\n    }\n}\n","// The entry file of your WebAssembly module.\nimport {Image} from \"./drawCross\";\nimport {Varianz} from \"./variance-average-brightness\";\n\nexport function cross(byteSize: i32, imageWidth: i32, imageHeight: i32, crossWidth: i32): i32 {\n    return Image.drawCross(byteSize, imageWidth, imageHeight, crossWidth);\n}\n\nexport function grayscale(byteSize: i32): i32 {\n    return Varianz.grayscale(byteSize);\n}\n","/// <reference path=\"../node_modules/assemblyscript/dist/assemblyscript.d.ts\" />\n\nimport {Util, Color} from \"./utils\"\n\nexport namespace Image {\n    export function drawCross(byteSize: i32, imageWidth: i32, imageHeight: i32, crossWidth: i32): i32 {\n        const centerWidth: i32 = imageWidth / 2;\n        const centerHeight: i32 = imageHeight / 2;\n        const halfCrossWidth: i32 = crossWidth / 2;\n        const crossWidthBeginning: i32 = centerWidth - halfCrossWidth;\n        const crossWidthEnding: i32 = centerWidth + halfCrossWidth;\n        const crossHeightBeginning: i32 = centerHeight - halfCrossWidth;\n        const crossHeightEnding: i32 = centerHeight + halfCrossWidth;\n\n        for (let row = 0; row < imageHeight; row++) {\n            for (let col = 0; col < imageWidth; col++) {\n                const readIndex = ((row * imageWidth) + (col)) * Util.COLOR_WIDTH;\n                const writeIndex = byteSize + readIndex;\n                if (row > crossHeightBeginning && row < crossHeightEnding || col > crossWidthBeginning && col < crossWidthEnding) {\n                    Util.fill(writeIndex, 253, 0, 255, 255);\n                } else {\n                    Util.copy(readIndex, writeIndex);\n                }\n            }\n        }\n        return 0;\n    }\n}\n","/// <reference path=\"../node_modules/assemblyscript/dist/assemblyscript.d.ts\" />\n\nimport {Util} from \"./utils\"\n\nexport namespace Varianz {\n\n    export function grayscale(byteSize: i32): i32 {\n        const CONST_R = 0.3;\n        const CONST_G = 0.59;\n        const CONST_B = 0.114;\n        for (let i = 0; i < byteSize; i += 4) {\n            const writeIndex = byteSize + i;\n\n            const avg = i32(CONST_R * load<u8>(i) + CONST_G * load<u8>(i + 1) + CONST_B * load<u8>(i + 2));\n            Util.fill(writeIndex, avg, avg, avg, 255)\n        }\n        return 0;\n    }\n}\n"]}